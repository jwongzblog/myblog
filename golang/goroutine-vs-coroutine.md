光听别人介绍一门技术，容易产生一些误解，比如演讲者忽略了这门技术的缺点，比如他本身就理解错误了，又比如演讲者尽量抽象的表达观点，怎么解释都对，而我自己就偏偏往错误的方向理解。**实践是检验真理的唯一标准**。

在接触golang之前，我从未听过**协程**，以为golang中goroutine就是协程，协程就是goroutine，具备高并发、并行能力，而且比线程更轻量，轻松启动百万级别的协程，这是c++的进程和线程无法比拟的优势。

所以当我得知python也实现了协程(coroutine)，我非常坚定的选择python做我们系统的web框架，然而我错了，错得很离谱。直到研究的深入，才发现错误的认知根源在哪。

其实很简单，我混淆了**并发**与**并行**的概念，具体详情请[知乎一下](https://www.zhihu.com/question/33515481/answer/199929767)，python的coroutine实现才是继承了1959年发布的大数据计算语言cobol，他的设计者定义了coroutine，我简单解释一下它的设计思想
* 它允许开发者将一段程序压入stack
* 一次只允许一个协程执行，可以利用多线程增加协程的并行能力，开发者可以主动切换协程，让出cpu
* 协程间无法通信

我只用coroutine去搭建python web service时，一遇到阻塞(比如故意sleep)，协程已经hold住socket了，但是抢不到cpu，一切就卡在那里

所以，我甚至怀疑goroutine能否叫做协程，goroutine的源码我还没看，据说是内核态的线程，这个比用户态的线程占用内存要小吗？所以一个goroutine不会有并行的问题，理论上他既支持高并发，也支持并行计算，我的认为比coroutine的设计更好

在有些场景coroutine还是有价值的，比如他不会带来抢占带来的损耗，他的内存再怎么讲还是比内核态的线程要小吧
